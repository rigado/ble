package h4

import "testing"

import "io"

func Test_Frames(t *testing.T) {
	d := &fh4{
		data: [][]byte{
			[]byte{0x04, 0x0e, 0x04, 0x01, 0x06, 0x20, 0x00},
			[]byte{0x04, 0x3e, 0x21, 0x02, 0x01, 0x00, 0x00, 0x92, 0x8a, 0x07, 0x0c, 0xda, 0xf8, 0x15, 0x02, 0x01, 0x02, 0x11, 0x07, 0xfc, 0x9d, 0xd0, 0xb3, 0xcb, 0x84, 0xe0, 0x84, 0x06, 0x42, 0xf3, 0xf7},
			[]byte{
				0xe1, 0xe0, 0xbf, 0xcb, 0xb0,
				0x04, 0x3e, 0x0c, 0x02, 0x01, 0x04, 0x00, 0x92, 0x8a, 0x07, 0x0c, 0xda, 0xf8, 0x00, 0xb9,
				0x04, 0x3e, 0x2b, 0x02, 0x01, 0x03, 0x01, 0x35, 0xfe, 0xf7, 0x3b, 0xf2, 0x7d, 0x1f, 0x1e, 0xff, 0x06, 0x00, 0x01, 0x09, 0x20, 0x02, 0x60, 0x16, 0x26, 0x0a, 0xd3, 0x4b, 0xa0, 0xbe, 0xb4, 0xb8, 0xca,
			},
		},
	}

	h := &h4{
		rxQueue: make(chan []byte, 10),
		done:    make(chan int),
		sp:      d,
	}
	h.frame = newFrame(h.rxQueue)
	go h.rxLoop()

	b := make([]byte, 128)
	c := 0
	for {
		n, err := h.Read(b)
		if err != nil {
			t.Log(err)
			break
		} else {
			t.Logf("%x", b[:n])
			c++
		}
	}

	h.Close()

	if c != 3 {
		t.Fatal()
	}
}

type fh4 struct {
	io.ReadWriteCloser
	idx  int
	data [][]byte
}

func (f *fh4) Read(b []byte) (int, error) {
	if f.idx >= len(f.data) {
		return 0, io.EOF
	}

	n := copy(b, f.data[f.idx])
	f.idx++

	return n, nil
}

func (f *fh4) Close() error {
	return nil
}
